importar extraerDolarYadio, { extraerEurYadio } desde '@/ve/yadio.extractor.esjs'
importar extraerDolarBcv, { extraerEurBcv } desde '@/ve/bcv.extractor.esjs'
importar { escribirRutaRegion } desde '@/utils/rutas.esjs'
importar { grupo, logError } desde '@/log.esjs'
importar tryToCatch desde 'try-to-catch'

exportar porDefecto asincrono funcion () {
  const log = grupo({ cron: 'cron.ve.esjs' })

  log.info('Inicio')

  const [error] = esperar tryToCatch(guardarDolares, log)

  si (error) {
    logError(log, error)
  }

  log.info('Fin')
}

asincrono funcion guardarDolares(log) {
  const [errorYadio, dolaresYadio] = esperar tryToCatch(extraerDolarYadio)

  si (errorYadio) {
    logError(log, errorYadio, { extractor: 'yadio.extractor.esjs' })
  }

  const [errorBcv, dolarBcv] = esperar tryToCatch(extraerDolarBcv)

  si (errorBcv) {
    logError(log, errorBcv, { extractor: 'bcv.extractor.esjs' })
  }

  const { oficial: euroBcv, paralelo: euroYadio } = esperar extraerEuros(log)

  const dolares = []

  si (dolarBcv) {
    dolares.agregar(dolarBcv)
  }

  si (dolaresYadio && dolaresYadio.longitud > 0) {
    dolares.agregar(...dolaresYadio)
  }

  si (dolares.longitud === 0) {
    retornar
  }

  const orden = ['oficial', 'paralelo', 'bitcoin']

  dolares.ordenar((a, b) => {
      const indexA = orden.indiceDe(a.fuente)
      const indexB = orden.indiceDe(b.fuente)
      retornar indexA - indexB
    }).mapear((dolar) => {
      escribirRutaRegion('ve', `/dolares/${dolar.fuente}`, dolar)
    })

  escribirRutaRegion('ve', '/dolares', dolares)

  const cotizaciones = []

  si (dolarBcv) {
    cotizaciones.agregar({
      fuente: dolarBcv.fuente,
      nombre: 'DÃ³lar',
      moneda: 'USD',
      compra: dolarBcv.compra,
      venta: dolarBcv.venta,
      promedio: dolarBcv.promedio,
      fechaActualizacion: dolarBcv.fechaActualizacion,
    })
  }

  si (euroBcv) {
    cotizaciones.agregar({
      fuente: euroBcv.fuente,
      nombre: euroBcv.nombre,
      moneda: euroBcv.moneda,
      compra: euroBcv.compra,
      venta: euroBcv.venta,
      promedio: euroBcv.promedio,
      fechaActualizacion: euroBcv.fechaActualizacion,
    })
  }

  escribirRutaRegion('ve', '/cotizaciones', cotizaciones)

  const euros = []

  si (euroBcv) {
    euros.agregar(euroBcv)
  }

  si (euroYadio) {
    euros.agregar({
      ...euroYadio,
      fuente: 'paralelo',
      nombre: 'Paralelo',
    })
  }

  escribirRutaRegion('ve', '/euros', euros)
}

asincrono funcion extraerEuros(log) {
  const [errorEurBcv, oficial] = esperar tryToCatch(extraerEurBcv)

  si (errorEurBcv) {
    logError(log, errorEurBcv, { extractor: 'bcv.extractor.esjs (EUR)' })
  }

  const [errorEurYadio, paralelo] = esperar tryToCatch(extraerEurYadio)

  si (errorEurYadio) {
    logError(log, errorEurYadio, { extractor: 'yadio.extractor.esjs (EUR)' })
  }

  retornar { oficial, paralelo }
}
